a distribut comput usual partial order set relev event relev event subset primit event comput import causality-rel comput problem immedi predecessor track ipt problem relev event fli addit control messag set relev event immedi predecessor partial order so ipt on-the-fli comput transit reduct hass diagram causal relat distribut comput paper ipt problem famili protocol relev event timestamp exactli immedi predecessor famili gener condit applic messag control inform size n number process sens famili messag size-effici ipt protocol way gener condit differ ipt protocol categori subject descriptor c24 [ distribut system ] gener term asynchron comput a distribut comput set process common goal main characterist comput fact process not share common global memori commun onli messag commun network moreov messag transfer delay finit unpredict comput model defin asynchron distribut system model particularli import system larg geograph area system subject unpredict load consequ concept tool mechan asynchron system import gener causal key concept behavior asynchron system ] precis event e f distribut comput crucial problem lot distribut applic causal occurr consequ occurr other causal event e set event e causal depend event not causal depend concurr vector clock ] process causal concurr event timestamp event process current valu vector clock correspond process way vector timestamp event possibl safe event causal not usual problem design interest onli subset event distribut execut eg onli checkpoint event meaning one interest consist global checkpoint ] causal depend concurr event distribut comput not desir applic ] other word event distribut comput onli subset relev paper interest restrict causal relat subset event relev event comput strict partial order causal relat transit consequ relev event causal relev event e onli subset immedi predecessor event such relev event causal path f unfortun onli vector timestamp event not possibl event causal past immedi predecessor fact vector timestamp e determin process last relev event belong210 causal e event not necessarili immedi predecessor e howev applic ] requir relev event onli set immedi predecessor applic mainli analysi distribut comput analys construct lattic consist cut comput ] [ ] track immedi predecessor effici fli construct lattic gener applic interest veri structur causal past context determin immedi predecessor major issu ] addit circumst determin behavior constraint commun pattern distribut comput not determin control messag immedi predecessor comput fli immedi predecessor track ipt problem fli addit messag immedi predecessor relev event problem actual transit reduct hass diagram causal graph relev event comput problem causal henc vector clock previou work effici implement vector clock causal depend relev event aim size timestamp messag effici vector clock implement system fifo channel [ ] effici implement not channel properti [ ] notion causal barrier [ ] size control inform causal multicast howev none paper ipt problem problem first time knowledg ] ipt protocol correct proof moreov protocol timestamp messag size n question knowledg never there effici vector clock implement techniqu suitabl ipt problem paper main contribut posit answer previou open question design famili effici ipt protocol formal correct proof associ protocol methodolog point view paper top-down approach abstract properti concret properti protocol famili ipt protocol gener condit applic messag control inform size system size number process system sens famili low cost ipt messag size addit effici approach interest design properti name famili increment step basic vector clock protocol first process boolean vector manag process immedi predecessor event then gener condit size control inform messag final way condit ipt protocol paper section section introduc comput model vector clock notion relev event section present first step construct result ipt protocol messag vector clock boolean array size n number process section protocol gener condit messag control inform size n section instanti condit section simul studi behavior protocol final section paper due space limit proof lemma theorem [ ] model and vector clock distribut comput a distribut program sequenti local program onli messag distribut comput execut distribut program execut local program rise sequenti process p1 p2 pn finit set sequenti process distribut comput pair process pi pj reliabl channel cij pi messag pj messag uniqu process not messag messag transmiss delay finit unpredict moreov channel not necessarili process speed posit arbitrari other word underli comput model asynchron local program pi intern statement execut such statement correspond send/receive/intern event event primit event ex i x-th event process pi sequenc hi = e1 i i ex i histori pi hi h = ∪n i=1hi set event distribut comput set partial order lamport s relat ] hb → ex i → j onli i j ∧ x = y local preced ∨ ∃m ex i send m ey j = receiv m msg prec ∨ ∃ ez k ex i → ez k ∧ k hb → ey j transit closur max ex i j partial function onli ex i ey j max ex i j i ey j hb → ex i max ex i j ey i ex → ey j clearli restrict hb → hi i total order notat ex i ey i x < y paper follow notat ∈ hi not first event pi then e event immedi e sequenc hi e first event pi then e ⊥ such event ∀e ∈ hi ⊥ < partial order bh = h hb → formal model distribut comput assumpt onli order simpl protocol p1 p2 p3 [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] figur relev event immedi predecessor graph hass diagram relev event observ distribut comput onli event relevant2 [ ] interest exampl observ detect predic consist global state distribut comput ] case relev event correspond modif local variabl global predic exampl checkpoint problem relev event definit local checkpoint [ ] left part figur distribut comput classic space-tim diagram figur onli relev event sequenc relev event process pi ri r = ∪n i=1ri ⊆ h set relev event → relat r follow way ∀ e f r × r → f ⇔ e hb → f poset r → abstract distribut comput ] follow distribut comput abstract level moreov loss gener set relev event subset intern event commun event relev intern event just send just receiv commun event relev event pair process id sequenc number figur definit relev causal event e ∈ h partial subset relev event such hb → e ↑ e e f ∈ r | hb → e note ∈ r then ↑ e f ∈ r | → e comput figur event e ↑ e follow properti immedi consequ previou definit e ∈ h cp1 e not receiv event then ↑ e < ∅ e = ⊥ ↑ e e e ∈ r ↑ e e r cp2 e receiv event messag m then ↑ e > > < > > ↑ send m e = ⊥ ↑ e send m e e ∈ r ↑ e send m e r event sometim observ event definit e ∈ hi j such ↑ e rj = ∅ last relev event pj respect lastr e j max f | f ∈↑ e ∩ rj ↑ e rj = ∅ lastr e j ⊥ such event event e figur e = e = e = follow properti event lastr e j f j predecessor e relat hb → properti directli definit e ∈ hi lr0 ∀e ∈ hi lastr e i < ⊥ e = ⊥ e e ∈ r lastr e i e r lr1 e not receipt event ∀j = i lastr e j = lastr e j e receiv event m ∀j = i lastr e j = max lastr e j send m j vector clock system definit fundament concept causal theori vector clock simultan independ fidg [ ] mattern [ ] a vector clock system mechan timestamp event such way comparison timestamp correspond event not causal first precis process pi vector integ v ci  n ] such v ci [ j ] number relev event pj current relev causal pi note v ci [ i ] number relev event so far pi process pi relev event e e vector timestamp valu ev c equal current valu v ci vector clock implement follow implement vector clock ] observ ∀e ∈ hi ∀j ev ci [ j ] = y ⇔ lastr e j ey j ev ci valu v ci just occurr e relat result directli properti lr0 lr1 lr2 process pi vector clock v ci  n ] follow rule vc0 v ci  n ] ] vc1 time relev event e pi vector clock entri v ci [ i ] v ci [ i ] = v ci [ i indic relev event then pi associ timestamp ev c = v ci vc2 process pi messag m current valu v ci mv c denot valu vc3 pi messag m vector clock ∀k v ci [ ] = max v ci [ k ] mv c [ k ] immedi predecessor section immedi predecessor track ipt problem section then technic properti immedi predecessor section properti basic ipt protocol correct section ipt protocol previous [ ] proof vector clock protocol manag local boolean array process ipt problem introduct applic eg analysi distribut execut ] detect distribut properti ] requir on-the-fli addit messag transit reduct relat → not transit causal depend relev event f e f immedi predecessor e f → e relev event g such → g → definit immedi predecessor track ipt problem relev event set relev event immedi predecessor moreov fli addit control messag ie commun pattern comput introduct ipt problem comput hass diagram partial order set relev event distribut comput formal properti ipt order protocol ipt problem use notion immedi relev predecessor event relev not first definit immedi predecessor pj event e necessarili lastr e j event second lastr e j immedi predecessor e not lastr e k event path lastr e j observ follow definit definit e ∈ hi set immedi relev predecessor e ip e set relev event lastr e j j = n such ∀k lastr e j ∈↑ lastr e k definit ip e lastr e j = n ⊂↑ e figur graph right part immedi predecessor relev event comput left part precis edg e f relev event e immedi predecessor relev event f follow lemma set immedi predecessor event predecessor relat hb → protocol ipt problem read paper proof appendix a intuit mean first lemma follow e not receiv event causal path e e next-to-last event cp1 so e relev event relev event relev causal past e pred e e onli immedi predecessor e other word event e reset wrt set immedi predecessor e other hand e not relev not relev causal e lemma e not receiv event ip e equal e = ⊥ e e ∈ r ip e e r intuit mean next lemma e receiv event receiv m causal path e e m next-to-last event e relev previou lemma event relev causal immedi predecessor e last relev predecessor send m onli not predecessor pred e immedi predecessor e lemma e hi receiv event messag m e ∈ ri then ∀j ip e ∩ rj equal e j = i lastr e j ≥ lastr send m j ip send m rj lastr e j < lastr send m j intuit mean next lemma follow e receiv event receiv m e not relev last relev event relev causal e pred e send m process so immedi predecessor e pred e send m process last relev event e send m same event f none path f relev event thu immedi predecessor event e m e hi receiv event messag m e ∈ ri then ∀j ip e ∩ rj equal ip e rj lastr e j > lastr send m j ip send m rj lastr e j < lastr send m j ip e send m lastr e j = lastr send m j a basic ipt protocol basic protocol here relev event e attribut set ip e immedi predecessor previou lemma set actual graph hass diagram partial order distribut comput ip e event e set ip event e and/or send m e = receiv m idea data structur set ip induct poset h hb → account inform e process boolean array ipi such ∈ hi valu ipi e denot eipi boolean array represent set ip e precis ∀j ipi [ j ] ⇔ lastr e j ∈ ip e section knowledg lastr e j e j manag vector v ci thu set ip e follow way ip e ey j | ci [ j ] = y ∧ [ j ] = j n process pi ipi lemma result lemma not receiv event current valu ipi suffici eipi result lemma receiv event e = receiv m then eipi involv inform event send m precis inform ip send m timestamp send m event lastr send m j e j j so vector m cj m ipj send m pj m moreov ipi occurr event fact valu ipi just event e valu succ e ipi particular lemma determin succ e e relev not thu valu ipi just occurr event e track event follow protocol previous [ ] proof correct manag array v ci section ipi lemma section timestamp relev event e et r0 initi v ci  n ] ipi [  n ] ] r1 time relev event e pi associ timestamp et = k v ci [ k ] ipi [ k ] pi vector clock entri v ci [ i ] name v ci [ i ] = v ci [ i pi ipi ∀ = i ipi [ ] = ipi [ i ] = pi messag m pj current valu v ci mv c boolean array ipi mip messag m pj pi follow updat ∀k ∈  n ] case v ci [ k ] < mv c [ k ] thenv ci [ ] = mv c [ k ] ipi [ ] = mip [ k ] v ci [ k ] = mv c [ k ] then ipi [ ] = min ipi [ k ] mip [ k ] v ci [ k ] > mv c [ k ] then proof follow theorem directli lemma protocol section ipt problem relev event e timestamp et identifi immedi predecessor other event identifi gener condit section previous open problem name ipt problem applic messag whole vector clock whole boolean array first gener condit entri vector v ci ipi control inform messag comput section then section condit suffici necessari howev gener condit not local process messag thu local evalu approxim gener condit approxim protocol addit local data structur sens gener condit famili ipt protocol previous open problem issu section transmit not transmit control inform let previou ipt protocol section rule r3 process pj not systemat updat entri v cj [ k ] time messag m process pi updat v cj [ k ] v cj [ k ] ≥ mv c [ k ] such case valu mv c [ k ] useless control inform m pi pj similarli entri ipj [ k ] not messag m pi pj < v cj [ k ] = mv c [ k ] ∧ mip [ k ] = v cj [ k ] > mv c [ k ] mv c [ k ] case mip [ k ] = ipi [ k ] then updat ipj [ k ] necessari differ other entri systemat < v cj [ k ] = mv c [ k ] ∧ mip [ k ] = observ definit condit k m k entri vector v ci ipi control inform messag m process pi process pj definit k m k ≡ send m ci [ k ] = ∨ send m ci [ k ] < receiv cj [ k ] ∨ m ci [ k ] = receiv cj [ k ] ∧ send m [ k ] = necessari suffici condit here condit k m k necessari suffici tripl form k send m ci [ k ] send m [ k ] outgo messag m pi pj a tripl also k c [ k ] mip [ k ] due space limit proof lemma lemma [ ] proof theorem directli lemma suffici k m k true then tripl k c [ k ] mip [ k ] useless respect correct manag ipj [ k ] v cj [ k ] lemma necess k m k fals then tripl k c [ k ] mip [ k ] necessari correct manag ipj [ k ] v cj [ k ] theorem process pi m process pj condit k m k necessari suffici not tripl k send m ci [ k ] send m [ k ] famili of ipt protocol base on evalu condit result previou theorem pi k m k m pj previou ipt protocol follow way rule r2 tripl k v ci [ k ] ipi [ k ] m onli ¬k m k moreov rule r3 appropri onli tripl m howev previous pi not local k m k m precis pi m pj pi exact valu send m ci [ k ] m [ k ] current valu v ci [ k ] ipi [ k ] as far valu receiv cj [ k ] case possibl case i receiv hb → send m then pi valu receiv cj [ k ] consequ k m k case ii receiv m concurr pi not valu receiv cj [ k ] consequ not k m k moreov m pj case i ii actual pi way case henc idea evalu approxim gener condit k m k approxim k m k process pi messag m correct condit k time pi tripl k v ci [ k ] ipi [ k ] theorem ie time ¬k m k then pi tripl condit k henc definit correct evalu approxim definit condit k local evalu process messag m process correct ∀ m k ¬k m k ⇒ ¬k m k equival ∀ m k k m k ⇒ k m k definit protocol k tripl messag not tripl transmiss theorem constant condit denot k1 alway fals m k k1 m k = fals trivial correct approxim k actual particular ipt protocol section messag whole vector clock whole boolean vector next section approxim k k2 boolean matrix-bas evalu condit condit k2 observ condit k sub-condit pj send m pi v ci [ k ] = x ipi [ k ] v cj [ k ] ≥ x receiv m figur evalu condit k2 local other not precis k ≡ ∨ α ∨ β ∧ b ≡ send m ci [ k ] = ≡ send m [ k ] local evalu wherea α ≡ send m ci [ k ] < receiv cj [ k ] β ≡ send m ci [ k ] = receiv cj [ k ] not easi boolean calculu a∨ α∨β ∧b =⇒ a∨α∨ β ∧ b ≡ k k ≡ ∨ γ ∧ b γ = α ∨ β ≡ send m ci [ k ] ≤ receiv cj [ k ] ie k ≡ send m ci [ k ] ≤ receiv cj [ k ] ∧ send m [ k ] = send m ci [ k ] so pi predic send m ci [ k ] ≤ receiv cj [ k ] correct approxim local evalu predic ci j k pi messag m pj ci j k ⇒ send m ci [ k ] ≤ receiv cj [ k ] inform ci j k local context pi receipt m pj not v cj [ k ] updat pj as much pi pk henc concret condit k2 follow k2 ≡ send m ci [ k ] ∨ ci j k send m [ k ] = now design such predic denot ci first case j i section process never messag second case j = k relat send m ci [ j ] ≤ receiv cj [ j ] alway true receipt m pj not v cj [ j ] thu ∀j = i ci j j true now case j = i j = k figur event e = receiv m e < m pj tripl k v c [ k ] m ip [ k ] m v c [ k ] ≥ v ci [ k ] henc m v c [ k ] = receiv m ci [ k ] v cj [ ] not that as long v ci [ ] not messag m pi pj follow send m ci [ k ] = receiv m ci [ k ] = send m cj [ k ] ≤ receiv m cj [ k ] ie ci j k true other word onc ci j k true onli event pi receipt messag v ci [ ] = i occurr relev event v ci [ ] similarli onc ci j k fals onli event true receipt messag m pj tripl k v c [ k ] m ip [ k ] m v c [ k ] ≥ v ci [ k ] order local predic j k process pi boolean matrix mi [ ] m [ j ] = ⇔ ci j k previou discuss matrix follow rule note i-th line not signific case j = i diagon alway equal m0 initi ∀ j k mi [ j k ] m1 time relev event e pi ith column matrix ∀j = i mi [ j i ] = m2 pi messag updat mi messag m pj pi follow updat ∀ k ∈  n ] case v ci [ k ] < mv c [ k ] then = i j k mi [ k ] mi [ j ] v ci [ k ] = mv c [ k ] then mi [ j ] v ci [ k ] > mv c [ k ] then follow lemma result rule m0-m3 theorem condit k2 m k correct [ ] ∀i pi pj ∀k send m [ j ] = ⇒ send m ci [ k ] ≤ receiv cj [ k ] theorem m messag pi pj k2 m k ≡ m [ j ] = ∧ send m [ k ] = ∨ send m ci [ k ] = k2 m k ⇒ k m k ipt protocol complet text ipt protocol previou discuss rm0 initi v ci  n ] ipi [  n ] ] ∀ j k mi [ j k ] time relev event e pi associ timestamp et et = k v ci [ k ] ipi [ k ] pi vector clock entri v ci [ i ] name v ci [ i ] = v ci [ i pi ipi ∀ = i ipi [ ] = ipi [ i ] = pi ith column boolean matrix ∀j = i mi [ j i ] = pi messag m pj set tripl process id integ boolean k v ci [ k ] ipi [ k ] | mi [ j ] = ∨ ipi [ k ] = ∧ v ci [ k ] > rm3 pi messag m pj follow updat ∀ k c [ k ] mip [ k ] m case v ci [ k ] < mv c [ k ] then v ci [ ] = mv c [ k ] ipi [ ] = mip [ k ] ∀ = i j k mi [ k ] actual valu column constant first updat fact ∀j mi [ j i onli receipt messag pj valu v cj [ i ] r3 mj [ i i = pj not v cj [ i pi so possibl protocol reset column mi [ ∗ i onli pi first relev event mi [ j ] v ci [ k ] = mv c [ k ] then ipi [ ] = min ipi [ k ] mip [ k ] mi [ j ] v ci [ k ] > mv c [ k ] then a tradeoff condit k2 m k tripl not mi [ j ] = ∧ ipi [ k ] = ∨ v ci [ k ] > first manag ipi [ k ] applic program precis ipt protocol not relev event onli correct manag ipi [ k ] differ matrix mi not problem specif auxiliari variabl ipt protocol so follow implic pi m mi [ j ] = ⇒ receiv cj [ k ] ≥ send m ci [ k ] fact manag mi protocol not applic program possibl protocol entri mi equal condit k2 m k often satisfied5 consequ protocol tripl here possibl tripl price few addit boolean vector previou ipt matrix-bas protocol section follow way rule rm2 rm3 modifi rule rm2 rm3 mi [ ∗ k ] kth column mi rm2 pi messag m pj follow set 4-upl process id integ boolean boolean vector k v ci [ k ] ipi [ k ] mi [ ∗ k ] | mi [ j ] = ∨ ipi [ k ] = ∧ v ci [ k ] rm3 pi messag m pj follow updat ∀ k c [ k ] mip [ k ] [  n ] m case v ci [ k ] < mv c [ k ] then v ci [ ] = mv c [ k ] ipi [ ] = mip [ k ] ∀ i mi [ k ] = mm [ k ] v ci [ k ] = mv c [ k ] then ipi [ ] = min ipi [ k ] mip [ k ] =i mi [ k ] = max mi [ k ] mm [ ] v ci [ k ] > mv c [ k ] then similarli proof [ ] possibl previou protocol still properti lemma name ∀i ∀m pi pj ∀k m [ j ] = ⇒ send m ci [ k ] ≤ receiv cj [ k ] previous protocol section valu matrix entri mi [ j k ] alway equal reader easili correctli matrix moreov k2 m k then alway fals actual k1 k m case whole vector messag intuit fact column matric m applic messag transit transmiss inform precis relev histori pk pj process pi causal sequenc messag pj pi contrast protocol section onli direct transmiss inform fact section predic c local matrix m exist messag m pj pi tripl k v c [ k ] m ip [ k ] m v c [ k ] ≥ v ci [ k ] exist direct transmiss inform messag m ipt protocol rule rm0 rm1 rm2 rm3 same condit k2 m k previou one interest tradeoff number tripl k v ci [ k ] ipi [ k ] transmiss number boolean vector addit size addit inform tripl non-bound integ name vector clock valu experiment studi section behavior previou protocol comparison simul studi ipt1 protocol section condit k1 m k alway equal ipt2 protocol section condit k2 m k messag tripl final ipt3 protocol section also condit k2 m k messag addit boolean vector section not in-depth simul studi protocol rather gener view protocol behavior end ipt2 ipt3 regard ipt1 precis ipt2 aim gain term tripl k v ci [ k ] ipi [ k ] not respect systemat transmiss whole vector ipt1 ipt3 aim tradeoff addit boolean vector number save tripl behavior protocol set program simul paramet simul differ paramet commun process featur paramet number process simul comput rate commun send/rec event time durat consecut relev event moreov independ particular topolog underli network fulli network intern event not presenc tripl k v ci [ k ] ipi [ k ] messag strongli frequenc relev event process differ time distribut consecut relev event eg normal uniform poisson distribut sender messag random law particular configur distribut comput scenario simul messag transmiss delay standard normal distribut final last paramet simul number send event simul paramet set behavior ipt protocol larg number simul differ paramet number process comput number commun event simul paramet λ poisson time distribut λ averag number relev event time interv so relev event begin simul uniform time distribut relev event averag commun event locat paramet standard normal time distribut so occurr relev event third part simul experi note previous simul scenario case scenario ipt2 ipt3 scenario correspond case relev event maxim frequenc ie time process messag relev event final ipt protocol same simul paramet simul result result figur 3a-3d figur gain protocol term number tripl not y axi respect number commun event x axi figur time distribut relev event ipt2 ipt3 behavior ipt1 total number piggyback tripl ipt2 ipt3 ipt1 even case figur scenario case gain veri begin simul last as long process pj ∀k v cj [ k ] case condit ∀k k m k satisfi as soon ∃k v cj [ k ] = ipt2 ipt3 ipt1 shape curv flat condit k m k longer figur first event simul slope curv ipt2 ipt3 steep same occur figur case scenario then slope curv decreas constant end simul fact as soon v cj [ k ] condit ¬k m k mi [ j ] = ∨ ipi [ k ] = display interest featur λ relev event onli veri begin simul figur veri steep slope other figur figur that as soon relev event averag % tripl not messag import matrix mi furthermor ipt3 benefit addit boolean vector tripl transmiss figur 3a-3c show averag gain ipt3 respect ipt2 close % final figur underlin even import matrix mi veri few relev event ipt2 ipt3 veri effici inde figur veri quickli gain number tripl veri high actual % tripl lesson simul cours simul result consist theoret result ipt3 alway equal ipt2 ipt2 alway ipt1 simul result first lesson concern matrix mi use quit signific mainli time distribut relev event hand figur larg number relev event veri short time ipt2 % tripl howev sensit gain ipt2 boolean vector ip ] relev event fact section manag matrix mi ipt2 not transit transmiss inform onli direct transmiss inform column mi equal potenti equal differ ipt3 benefit addit boolean vector transit transmiss inform gain % other hand veri few relev event larg period time figur behavior ipt2 ipt3 veri effici transmiss % tripl fact veri quickli boolean vector ipi ] matrix mi veri few veri few relev event thu direct transmiss inform suffici quickli matric mi equal ] [ ] second lesson concern ipt3 precis tradeoff addit piggyback boolean vector number tripl transmiss n = boolean tripl not substanti size figur 3a-3c number tripl transmiss averag gain number tripl ipt3 respect ipt2 about % conclus paper import causality-rel comput problem name immedi predecessor track problem famili protocol relev event timestamp exactli immedi predecessor famili gener condit applic messag control inform size n number process sens famili messag size-effici ipt protocol way gener condit differ ipt protocol simul experi interestingli also effici protocol term size control inform not applic messag pattern commun event relev event last not not interest immedi predecessor event protocol paper ipi boolean vector boolean matric mi result protocol vector clock system particularli effici as far size timestamp messag interestingli effici not price addit assumpt such fifo channel 