famili vickrey-clarke-grov vcg mechan arguabl celebr achiev truth mechan design howev vcg mechan limit onli problem utilitarian affin object function output object function mani optim problem optim output comput intract vcg mechan polynomial-tim algorithm optim solut mechan no longer truth light limit use truth non-vcg payment scheme comput tractabl alloc rule o paper attent binari demand game agent onli avail action part game not problem truth mechan m = o p proper payment method p alloc rule o certain monoton properti gener framework such p propos sever gener composition-bas techniqu p effici variou type output particular p or/and combin round-bas combin complex combin output subgam categori subject descriptor f2 [ analysi algorithm problem complex ] gener j4 [ social behavior scienc ] econom k44 [ comput societi ] electron commerc gener term algorithm econom theori introduct recent year rapid develop internet mani protocol algorithm internet effici reliabl internet complex distribut system multitud heterogen agent common goal protocol algorithm often agent prescrib rule deviat howev set agent selfish instead altruist reason agent ration own profit neoclass econom new model selfish behavior such agent end nisan ronen [ ] framework algorithm mechan design appli vcg mechan fundament problem comput scienc path minimum span tree unrel machin vcg mechan [ ] applic design problem output utilitarian object function simpli sum agent valuat unfortun object function not utilitarian even problem utilitarian object function sometim imposs optim output polynomi time p=np other vcg mechan issu archer tardo [ ] schedul problem np-hard optim output certain monoton properti output work load necessari suffici condit exist truth mechan schedul problem auletta al ] similar schedul problem famili determinist truth + -approxim mechan fix number machin sever + -truth mechan np-hard restrict schedul problem lehmann al ] single-mind combinatori auction m-approxim truth mechan m number good also certain monoton alloc rule truth mechan work mu alem nisan [ ] spirit work truth mechan certain monoton properti single-mind auction also max if-then-els output subproblem paper max if-then-els combin special case composition-bas techniqu paper payment polynomi time mild assumpt gener truth mechan binari demand game alloc agent either not also valuat agent uncorrel valuat agent onli own alloc type mechan m = o p part alloc rule o payment scheme p previous often object function g alloc rule o optim g exactli approxim contrast vcg mechan not alloc object function fact not even exist object function alloc rule o binari demand game truth mechan m = o p game onli o certain monoton properti monoton properti onli exist payment scheme p such o p truth exist theorem gener framework payment scheme p furthermor gener techniqu payment output composit output subgam oper round-bas combin intermedi result other subproblem remaind paper section preliminari previou work defin binari demand game basic assumpt binari demand game section o certain monoton properti necessari suffici condit exist truth mechan m = o p framework then section payment p polynomi time sever type alloc rule o section sever exampl effect gener framework paper section possibl futur direct mechan design as usual literatur design algorithm protocol input individu agent assumpt neoclass econom agent ration well-defin incent protocol onli deviat gain standard model mechan design n agent n agent i privat inform ti type onli exampl type ti cost agent i packet network payment agent will good auction agent type type vector t = t1 t2 tn agent i set strategi ai input vector = a1 agent i strategi ∈ ai mechan m = o p output o = o payment vector p = p1 pn here payment pi · money i strategi agent game g = s m s set game g here s paramet game game not player strategi exampl unicast rout game [ ] consist topolog network sourc node destin node paper explicitli otherwis s game onli interest p alloc rule o valuat function v ti o monetari amount agent i possibl output o game s m set s alloc rule o payment scheme p public knowledg agent i actual type ti privat inform agent i ui ti o util agent i outcom game o prefer ti here common assumpt literatur util agent i quasi-linear ti o = v ti o + pi a|i = a1 · · · ai−1 ai ai+1 · · · agent j = i action aj agent i ai a−i = a1 · · · ai−1 ai+1 · · · action agent i sometim a−i bi a|i bi action ai domin i weakli util i possibl strategi b−i other agent ti o b−i ui ti o b−i ai = ai b−i direct-revel mechan mechan onli action avail agent privat type truth fals mechan incent compat ic mechan direct-revel mechan agent type ti truth then util then direct-revel mechan ic payment scheme properti agent i v ti o t pi t ≥ v ti o t|i ti pi t|i ti common requir literatur mechan design so call individu ration voluntari particip agent s util output mechan not util agent not direct-revel mechan strategproof ic ir properti arguabl import posit result mechan design gener vickrey-clarke-grov vcg mechan vickrey [ ] clark ] ] vcg mechan appli affin maxim problem object function utilitarian g t p i v ti o sum agent valuat set possibl output finit direct revel mechan m = o t p t vcg famili alloc o t maximizesp i v ti o payment agent i pi t p j=i vj tj o t hi t−i hi arbitrari function t−i mild assumpt vcg mechan onli truth implement utilitarian problem ] alloc rule vcg mechan object function rang alloc function mechan comput intract mani case furthermor optim algorithm output approxim algorithm usual untruth mechan vcg payment scheme paper truth mechan not utilitarian object function binari demand a binari demand game game g = s m m = o p rang o n other word output n-tupl vector o t = o1 t o2 t t oi t respect agent i respect not exampl binari demand game unicast [ ] multicast [ ] gener construct links/nod properti facil locat ] certain auction [ ] hereaft further assumpt valuat agent not ti o function v ti oi onli v ti oi valuat v ti oi publicli valu assumpt ir properti thu paper onli direct-revel mechan agent onli valuat vi = v ti notic applic agent servic payment eg unicast job schedul valuat vi agent i usual neg conveni present cost agent ci = −v ti agent i servic paper ci instead vi analysi result case agent servic rather ci neg auction binari demand game object function g t then binari optim demand game main differ binari demand game problem vcg mechan object function utilitarian maxim problem problem solvabl vcg restrict object function binari demand game alloc rule o here not necessarili object function vcg mechan onli output object function even not exist object function agent valuat not binari demand game agent valuat vcg mechan paper technic conveni object function g c exist continu respect cost ci result directli applic discret case modif previou work lehmann al ] effici truth mechan single-mind combinatori auction singlemind combinatori auction agent i ≤ i ≤ n onli subset si ⊆ s privat price ci single-mind bidder i bid bi = si ai si ⊆ s ∈ r+ [ ] set good agent i si ∅ exact lehmann al greedi round-bas alloc algorithm rank ai |si|1/2 approxim ratio √ m m number good s approxim algorithm truth payment scheme alloc rule exact set good agent i si monoton propos money good not bidder bid truth payment scheme charg bidder certain amount not own bid charg bidder notic assumpt exact reveal singl mind auction inde binari demand game payment scheme payment scheme binari demand game [ ] archer al combinatori auction multipl copi mani differ item sale bidder i onli subset si random round method incent compat truth mechan combinatori auction singl paramet agent approxim social valu auction method strongli truth sens truth high probabl − error probabl contrari paper determinist mechan truth alloc rule [ ] archer tardo truth mechan sever combinatori problem agent s privat inform natur singl posit real number alway cost unit load mechan s output arbitrari real number valuat quasi-linear function t · w t privat unit cost w work load archer tardo truth mechan work curv truth payment pi bi = pi + biwi bi r bi wi u du model archer tardo truth mechan sever relat problem span flow weight sum complet time problem notic load problem w = inde binari demand game character truth mechan decreas work curv w impli exactli monoton properti output proof heavili assumpt output continu function cost thu conclus directli binari demand game paper ahuva mu alem noam nisan ] spirit work clearli onli limit class bidder singl bidder [ ] truth mechan monoton output payment scheme cut valu simpl gener conclus gener binari demand game sever combin method max if-then-els construct partial search method welfar function output biton properti distinct contribut previou result [ ] singl combinatori auction payment scheme result truth mechan alloc rule certain monoton properti theorem also monoton properti applic set singl combinatori auction addit binari demand game here differ tradit pack ip s onli alloc agent binari alloc rule certain monoton properti not restrict object function furthermor main focu paper gener techniqu truth payment scheme alloc rule o certain monoton properti gener approach properti strategyproof mechan sever properti order truth mechan m = o p ic then ∀i oi t|i ti1 = oi t|i ti2 then pi t|i ti1 = pi t|i ti2 strategy-proof mechan binari demand game g s cost c−i agent other i payment agent i constant p1 i oi c constant p0 i oi c set s binari demand game mechan m = o p ic then mechan m = o p same output method o pi c = pi c − δi c−i function δi c−i also ic proof theorem straightforward thu due space limit theorem impli binari demand game alway payment agent i such payment agent not hereaft onli normal payment scheme exist strategyproof mechan notic s mechan design problem part alloc rule o payment scheme p paper alloc rule attent truth payment scheme o given alloc rule o binari demand game first suffici necessari condit exist truth payment scheme p definit monoton non-increas properti mp output method o monoton non-increas properti agent i possibl cost < ci2 oi c|i ci2 ≤ oi c|i ci1 definit not onli binari demand game binari demand game definit oi c|i ci2 then oi c|i ci1 set s c−i binari demand game g alloc rule o follow condit equival valu κi o c−i cut valu such oi c < κi o c−i oi c > κi o c−i ci = κi o c−i oi c either tie-break alloc rule o hereaft not tie-break scenario proof alloc rule o mp truth payment scheme p binari demand game proof proof condit impli condit straightforward here then condit impli condit proof similar proof ] direct agent i valuat vector ci1 c|i ci2 ci1 < ci2 oi c|i ci2 oi c|i ci1 corollari pi c|i ci1 p0 i pi c|i ci2 p1 i now fix c−i util i ci = ci1 ui ci1 p0 i agent i valuat util p1 i ci1 m = o p truth i p1 i ci1 now scenario actual valuat agent i ci = ci2 util p1 i ci2 true valuat similarli valuat util p0 i m = o p truth i p1 i ci2 consequ i > p0 i p1 i inequ ci1 > ci2 contradict then condit impli condit payment scheme payment scheme truth payment scheme oi c then agent i payment pi c = κi o c−i payment pi c condit oi c then > κi o c−i thu util κi o c−i ci > payment scheme ir follow payment scheme also ic properti case here case ci < κ o c−i case i true cost ci util κi o c−i ci now situat i cost di = ci di o c−i then i same payment util still di o c−i then util not anymor thu incent case case ci ≥ κ o c−i case i true valuat payment util now situat i valuat di = ci di o c−i then i same payment util still not di o c−i then util κi o c−i ci ≤ now thu incent equival monoton properti alloc rule o exist truth mechan o game binari demand game detail here due space limit now process truth payment scheme binari demand game output method o gener framework truth mechan design binari demand game stage check alloc rule o mp not then payment scheme p such mechan m = o p truth otherwis payment scheme p stage alloc rule o cut valu κi o c−i agent i such oi c|i di di < κi o c−i oi c|i di di > κi o c−i stage payment agent i oi c payment κi o c−i oi c payment gener framework minimum truth payment scheme o output comput cut valu function truth payment scheme gener framework difficult stage stage notic binari search not gener valuat agent continu gener techniqu cut valu function certain circumst basic approach first alloc rule sever alloc rule next cut valu function new alloc rule then origin cut valu function valu function new alloc rule simpl combin subsect techniqu cut valu function multipl alloc rule conjunct disconjunct simplic alloc rule o κ o c n-tupl vector κ1 o c−1 κ2 o c−2 κn o c−n here κi o c−i cut valu agent i alloc rule o cost c−i other agent fix s binari demand game m alloc rule o1 o2 · · · om monoton properti κ oi c cut valu vector oi then alloc rule o c wm i=1 oi c monoton properti moreov cut valu o κ o c maxm i=1 κ oi c here κ o c maxm i=1 κ oi c ∀j ∈ [ n ] κj o c−j maxm i=1 κj oi c−j o c i=1 oi c ∀j ∈ [ n ] oj c o1 j c o2 j c · · · ∨ om j c proof assum ci > ci oi c loss gener ok i c k ≤ k ≤ m assumpt ok i c mp ok i c|i ci thu oi c|i ci wm j=1 oj c o c mp correct cut valu function directli theorem mani algorithm inde categori use theorem concret exampl here network sometim packet set node instead problem multicast commonli use structur multicast rout so call path tree spt network g = v e c v set node vector c actual cost node data sourc node s receiv q ⊂ v receiv qi ∈ q path cost path lcp qi d sourc s cost profil union such shortest path path tree then gener framework truth payment scheme p spt structur output multicast mechan m = spt p notic vcg mechan not here spt not affin maxim lcp qi alloc path lcp qi d lcp qi k d onli node vk lcp qi d then output spt w qi∈q lcp qi other word sptk d onli lcp qi d path alloc rule utilitarian satisfi mp thu theorem spt also mp cut valu function vector spt κ spt c maxqi∈q κ lcp qi c κ lcp qi c cut valu function vector path lcp qi c consequ payment scheme truth minimum truth payment scheme alloc rule spt theorem s binari demand game m output method o1 o2 · · · om mp κ oi c cut valu function respect oi i · · · m then alloc rule o c i=1 oi c mp moreov cut valu function o κ o c minm i=1 κ oi c simpl combin if-thenels function [ ] agent i alloc rule o1 o2 mp κi o1 c−i κi o2 c−i cut valu function o1 o2 respect then if-then-els function oi c actual oi c = [ ci ≤ κi o1 c−i + δ1 c−i o2 c−i ci ] ∨ ci < κi o1 c−i − δ2 c−i δ1 c−i δ2 c−i posit function theorem alloc rule o mp consequ κi o c−i max min κi o1 c−i + δ1 c−i κi o2 c−i κi o1 c−i − δ2 c−i round-bas alloc approxim algorithm round-bas round algorithm agent set cost profil necessari exampl sever approxim algorithm minimum weight vertex cover ] maximum weight independ set minimum weight cover [ ] minimum weight steiner ] tree fall categori exampl minimum vertex cover problem mwvc ] cut valu round-bas output graph g = v e node v1 v2 agent agent vi weight ci node v ⊆ v such edg u v e u v v such v vertex cover g valuat node i −ci valuat subset node v ∈ v weight c v p i∈v ci vertex cover minimum weight henc object function utilitarian vcg mechan vertex cover minimum weight np-hard [ ] interest mechan polynomi time polynomial-tim comput alloc rule mani algorithm literatur optim solut paper 2-approxim algorithm [ ] sake complet algorithm here algorithm round-bas round vertic discard vertic node i w i weight ci w i i vertex cover present clear edg i1 j1 lexicograph edg i2 j2 min i1 j1 < min i2 j2 min i1 j1 = min i2 j2 i1 j1 < max i2 j2 approxim minimum vertex cover input node graph g = v e c output vertex cover v set v = ∅ i v w i = ci v not vertex cover pick uncov edg i j lexicograph order uncov edg = min w i j updat w i i m w j j m w i i v w j j v notic edg lexicograph order crutial monoton properti vertex cover v weight time optimum conveni vc c vertex cover algorithm cost vector vertic c gener scenario typic round-bas output algorithm updat rule ur crossingindepend agent i not round r sr+1 −i not cr j cr −i cr i1 ≤ cr i2 impli i1 ≤ cr+1 i2 follow theorem exist truth payment round alloc rule a theorem round-bas output a framework algorithm satisfi mp output method mp updat rule ur crossing-independ proof agent i c−i agent i cost ci then also cost di ci i round r cost ci then cost di agent i round r claim otherwis round r clearli set sr cost other agent same agent i ci i not previou round due crossindepend properti i round r cost ci i also round r di < ci due reason satisfi mp proof algorithm a gener round-bas alloc rule a set r c0 = c g0 = g initi repeat comput output determinist algorithm sr × cr → n here or cr sr alloc rule cost vector game set game gr respect remark often simpl greedi algorithm such agent utilitarian function exampl vertex cover or alway light-weight node lexicograph uncov edg i j = r game gr−1 new game gr sr cost vector cr rule or−1 × sr−1 cr−1 → sr cr here cost set game remark exampl vertex cover updat rule weight vertic i j min i j valid output union set select player round final output exampl vertex cover union node round comput cut valu round-bas algorithm input round-bas output a game g1 = g updat function vector u output cut valu x agent k set r = ζ ζ valu ak = agent cost ζ repeat comput output determinist algorithm sr alloc rule sr ×cr → n cut valu agent k alloc rule or cost cr −k r = κk or cr −k cut valu set r = r new game gr gr−1 updat rule ur cr new cost vector game gr valid output gi x cost ci k origin cost vector c|k x minimum valu x such > > > > > < > > > > > g1 x g2 x gt−1 x ≥ t−1 gt x t here total number round valu x cut valu round-bas output satisfi monoton properti cut-valu alway then cut valu agent k algorithm correct algorithm straightforward cut valu cut valu r round r polynomi time equat gr x r x polynomi time cost vector c−i b now vertex cover problem round r vertex weight incid lexicograph uncov edg output satisfi mp agent i cost i − cr j iff edg i j easi updat rule crossing-independ thu algorithm cut valu set cover game algorithm comput cut valu mvc input node graph g = v e c node k algorithm output cut valu κk v c c−k i v w i = ci set w k = ∞ pk v = ∅ v not vertex cover pick uncov edg i j lexicograph order uncov edg set m = min i j updat w i = w i m w j = w j m w i i v els j v i k j == then pk = pk + output pk cut valu κk v c c−k complex combin subsect cut valu function output binari demand game simpl combin output cut valu other mean typic vcg howev algorithm not way subsect complex way alloc rule way cut valu also complic n agent ≤ i n cost vector c m binari demand game gi object function c si alloc rule i · · · m binari demand game s alloc rule o input cost vector d = d1 d2 · · · dm f function vector f1 f2 · · · fm ψ alloc rule vector ψ2 · · · ψm set vector s1 s2 · · · sm notat simplic fi c = fi ψi c c ≤ i ≤ m f c = f1 c f2 c · · · fm c concret exampl combin link graph g = v e c subset q node q ⊆ v steiner tree problem set link minimum total cost q way approxim steiner tree virtual complet graph h q vertic cost edg i j cost lcp i j c graph g minimum span tree h mst h edg g iff lcp i j c edg i j h mst h game q q − /2 game gi j i j ∈ q object function j c minimum cost i j graph g si origin graph g alloc rule lcp i j c game g mst game graph h cost pair-wis q q − /2 path input vector d = d1 d2 · · · dm game mst detail section definit alloc rule o s object function vector f alloc rule vector ψ vector ∫ compound binari demand game s output o ◦ f o ◦ f i c wm j=1 oj f c ψj i c alloc rule abov definit agent i onli j such i ψj c alloc rule o index j cost profil f c simplic o ◦ f output compound binari demand game notic truth payment scheme o ◦ f output exist onli monoton properti o ◦f satisfi mp sever necessari definit order definit function monoton properti fmp given object function g alloc rule o function h c = g o c c function monoton properti c−i oi c h c not ci oi c h c not ci definit strong monoton properti smp alloc rule o strong monoton properti o mp agent i oi c agent j = i oi c|j cj ≥ cj oj c|j cj alloc rule o satisfi smp cost vector ci = ci oi c oi c then j = i such < cj oj c definit strong monoton properti directli now suffici condit o ◦ f monoton properti ∀i ∈ [ m ] fi fmp ψi mp output o smp then o ◦ f mp proof cost vector c o ◦ f i c cost vector = c|i ci ci < ci o ◦ f i c o ◦ f i c loss gener ok f c i c index ≤ k ≤ m now output o cost vector f c |k fk c scenario scenario index k not output function o from lemma j = k such fj c < fj c oj f c |k fk c then agent i output ψj c i c not ψj c mp i c ψj i c ci < ci fj satisfi fmp fj c ≥ fj c contradict inequ consequ i c equat fact index k not alloc rule o definit smp oj f c thu agent i o ◦ f oj f c i c other scenario index k output function o first agent i ψk c output ψk c monoton properti ci < ci ψk i c secondli function fk fmp fk c ≤ fk c rememb output o smp thu ok f c fact ok f c |k fk c fk c ≤ fk c consequ agent i also final output o ◦ f proof theorem cut valu compound output o ◦ f then cut valu output algorithm κi o ◦ f o smp ψj satisfi mp c−i fj c constant ψj i c fj c ψj i c notic here easili ci = ∞ ψj monoton properti i c−i fi j −1 y x such fj c|i x y simplic fi j −1 f−1 j confus i fix agent paper y such x polynomi time find cut valu compound method o ◦ f input alloc rule o object function vector f invers function vector f−1 = f−1 · · · f−1 m alloc rule vector ψ c−i output cut valu agent i o ◦ f ≤ j ≤ m output ψj ci comput hj = fj c|i ∞ use h = h1 h2 · · · hm input output function o denot τj = κj o h−j cut valu function output o input h ≤ j ≤ m set κi j = f−1 j min τj cut valu i κi o ◦ f c−i maxm j=1 κi j theorem correct cut valu agent i alloc rule o ◦ f proof order correct cut valu function algorithm case conveni κi κi o ◦ f c−i confus first di < κi then o ◦ f i c|i di loss gener κi = κi j j function fj fmp ψj i c|i di fj c|i di < fj κi notic < κi j definit κi j = f−1 j min τj ψj i c|i di fj c|i di < due fact fj x non-decreas function j thu monoton properti o τj cut valu output o oj h|j fj c|i di oj f c|i di then o◦f i c|i di otherwis o satisfi smp lemma equat impli index such ok f c|i di fk c|i di < hk note fk c|i di hk impli i ψk c|i di hk = fk ci|i ∞ other word agent i o◦f second di o ◦ f c−i then o ◦ f i c|i di sake contradict o ◦ f i c|i di then index ≤ j ≤ m such oj f c|i di i c|i di hk ≥ fk c|i di k thu fact o satisfi smp cost vector f c|i di fj c|i di still oj h|j fj c|i di fj c|i di < τj abov inequ fact fj c|i c|i di < hj fj c|i di min hj τj < f−1 j min hj τj κi j < κi o ◦ f c−i contradict proof applic alloc rule implement object function fj fj utilitarian thu invers f−1 j effici issu condit algorithm restrict howev lot game practic satisfi properti here max combin [ ] assum a1 a2 alloc rule singl combinatori auction then combin max a1 a2 alloc welfar algorithm a1 a2 mp fmp oper max element x y satisfi smp from theorem combin max a1 a2 also mp further cut valu max combin algorithm section complex combin complic problem concret exampl set cover set cover problem set u m element agent ≤ i n subset element si cost ci s = s1 s2 · · · sn c = c1 c2 · · · cn subset agent d such u ⊆ s i∈d si select subset set cover u social effici output d p i∈d ci object function clearli utilitarian thu vcg mechan subset s u minimum cost well-known optim solut np-hard [ ] algorithm approxim ratio hm ratio possibl set cover problem complet present method here algorithm greedi set cover gsc input agent i s si cost ci ≤ i ≤ n output set agent element initi r = t0 = ∅ r = ∅ r = u set sj minimum densiti cj |sj −tr| set tr+1 = tr s sj r = r s j r = r output r let gsc s set algorithm output function s work type agent si public knowledg here gener case type agent si ci other word agent i not onli cost ci also set si problem now similar combinatori auction singl bidder [ ] follow differ set cover problem element set overlap combinatori auction set disjoint mechan m = gsc pv cg algorithm set cover vcg mechan payment agent not truth obvious set cover problem binari demand game moment agent i t abl si assumpt later truth mechan gener framework monoton properti output algorithm round-bas output thu agent i first output round r round r i algorithm then minimum ratio ci |si−tr| agent now case i cost < ci obvious ci |si−tr| still minimum agent consequ agent i still round r output round r satisfi mp now updat rule round onli tr+1 = tr s sj r = r s j obvious cross-independ thu theorem output algorithm satisfi mp cut valu cut valu agent i fix cost vector c−i step algorithm first ci = ∞ algorithm ir agent round r t−i r+1 correspond set then cut valu round r r = cir |sir − t−i r | · |si − t−i r | rememb updat rule onli game not cost agent thu x x ≥ r ≤ r ≤ t therefor final cut valu agent i κi gsc c−i = max r cir |sir − t−i r | · |si − t−i r | payment agent i κi i payment now scenario agent i si assum agent i not upward onli set si ⊆ si agent i not element si notic cut valu round r r = cir |sir −t −i r | · |si − t−i r | obvious |si − t−i r | ≤ |si − t−i r | si ⊆ si thu set si not cut valu round thu si not agent i s util link weight steiner tree consid link network g = v e c e = e1 e2 · · · em set link ci weight link ei link steiner tree problem tree sourc node s set node q = q1 q2 · · · qk ⊂ v simplic qi = vi ≤ i k here link agent total cost link graph h ⊆ g weight h ω h np-hard minimum cost multicast tree arbitrari link graph g [ ] current polynomi time method approxim ratio + [ ] here first approxim method takahashi matsuyama [ ] algorithm find linkweight steinertre lst input network g = v e c c cost vector link e sourc node s receiv q output tree lst s receiv set r g1 = g q1 = q s1 = repeat graph gr receiv sourc s lcp qi c cost path s receiv qr select link lcp qi c relay link cost new graph gr+1 set tr qi pr = lcp qi c set qr+1 = qr \qi r = r receiv hereaft lst g final tree abov method [ ] mechan m = lst pv cg not truth pv cg payment vcg mechan then truth payment scheme gener framework output pr round r satisfi mp updat rule round crossing-independ thu theorem output lst mp round r cut valu link ei vcg mechan now ci = ∞ algorithm w−i r ci cost path pr ci rth round πi r ci path round r cost ci temporarili then cut valu round r r = wi r c−i − |πi r c−i | |πi r c−i | cost path πi r c−i node vi algorithm final cut valu agent i κi lst c−i maxr r thu payment link ei κi lst c−i cost di < κi lst d−i otherwis payment virtual minim span tree set receiv sourc node steiner tree algorithm virtual minimum span tree also often q set receiv sender node node-weight graph agent virtual minimum span tree algorithm construct vmst pair receiv qj ∈ q cost path lcp qi qj d construct virtual complet link graph k d q node set link qiqj cost path lcp qi qj d weight w qiqj = |lcp qi qj d | minimum span tree k d v mst d virtual link qiqj v mst d correspond cost path lcp qi qj d origin network mark agent lcp qi qj d mechan m = v mst pv cg not truth [ ] payment pv cg node vcg mechan then truth mechan framework monoton properti rememb complet graph k d weight link qiqj |lcp qi qj d | other word implicitli |q| |q| − /2 function j i < j qi ∈ q qj ∈ q fi j d = |lcp qi qj d | function fi j d = |lcp qi qj d | satisfi fmp lcp mp output mst smp from theorem alloc rule vmst monoton properti cut valu notic vmst combin mst function fi j so cut valu vmst algorithm link complet graph k d q cut valu function edg ek = qi qj mst span tree t pair termin p q clearli uniqu path t path πt p q edg maximum length path le p q t thu cut valu κk mst d = le qi qj mst d|k ∞ b value-cost function lcp assum vk ∈ lcp qi qj d then value-cost function xk = yk − |lcpvk qi qj | here lcpvk qi qj d cost path qi qj node vk path c remov vk valu k d|k ∞ set h i j = |lcp qi qj d|∞ | pair node i j = h i j vector then easi τ i j = |le qi qj mst h| i j ∞ | cut valu output vmst easi min h i j τ i j |le qi qj mst h | thu i j k v mst d |le qi qj mst h |− |lcpvk qi qj | cut valu agent k κk v mst d−k = max0≤i j≤r κij k v mst d−k agent k κk v mst d−k onli v mst d els combinatori auction lehmann al ] effici truth mechan single-mind combinatori auction singlemind combinatori auction set item s set agent ≤ i n item agent i subset si ⊆ s maximum price mi single-mind bidder i bid bi = si ai si ⊆ s ∈ r+ bid si ai sj aj conflict si ∩ sj = ∅ bid b1 b2 · · · bn greedi round-bas algorithm first bid criterion ai |si|1/2 [ ] order l list sort bid first bid then algorithm exam bid l order grant bid not bid previous greedi alloc scheme criterion ai |si|1/2 optim alloc factor √ m m number good s auction set = −ai easi output greedi algorithm round-bas output rememb bidder j round r bidder j not round cost bidder conflict j crossing-independ addit round bidder i ai then still ai > ai thu round mp cut valu |si|1/2 · ajr |sjr |1/2 jr bidder round r not agent i notic |sjr |1/2 not round r increas final cut valu |si|1/2 · aj |sj |1/2 bj first bid not onli presenc bidder i thu payment agent i |si|1/2 · aj |sj |1/2 ai ≥ |si|1/2 · |sj |1/2 otherwis payment scheme exactli same payment scheme ] conclus paper truth mechan m = o p alloc rule o binari demand game first alloc rule o mp necessari suffici condit truth mechan m then gener framework payment p such mechan m = o p truth comput polynomi time further sever gener composition-bas techniqu p effici variou alloc rule o sever concret exampl gener framework p composition-bas techniqu p polynomi time paper p polynomi time algorithm not necessarili optim run time p o interest algorithm p optim time progress research direct ] algorithm payment unicast node graph optim o n log n + m time research direct approxim alloc rule o mp good approxim ratio binari demand game mani work ] mechan design literatur direct here goal paper not alloc rule problem algorithm payment effici o signific alloc rule good approxim ratio such binari demand game comput effici payment scheme paper mechan design binari demand game howev problem not directli binari demand game job problem ] such exampl problem truth payment scheme p alloc rule o onli workload o monoton certain manner interest framework truth payment scheme binari demand game non-binari demand game research direct theorem gener alloc rule o rang r+ difficulti then payment p mild assumpt valuat truth mechan m = o p acknowledg rakesh vohra tuoma sandholm anonym review help comment discuss 